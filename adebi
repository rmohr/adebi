#!/usr/bin/env python
#
# Copyright 2013 Roman Mohr.
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import argparse
import re
import subprocess
import tempfile
import shutil
import os
import sys
import glob
from collections import namedtuple

PACKAGE = r'([^\s()<>=_,;]+)'
VERSION = r'\(([^\s(),;]+)\)'
DELIMITER = r'([\s,;]+)'
END = r'$'
TOKENS = [PACKAGE, VERSION, DELIMITER, END]


class TokenException(Exception):
    pass


def cleanup(origin, tempdir):
    os.chdir(origin)
    shutil.rmtree(tempdir)


def tokenize(dependencies):
    rest = dependencies
    while rest:
        token, token_type = next_token(rest)
        while token_type == DELIMITER:
            rest = rest[token.end():]
            token, token_type = next_token(rest)
        if token_type == END:
            return
        yield (token.group(1), token_type)
        rest = rest[token.end():]


def next_token(string):
    for t in TOKENS:
        token = re.match(t, string)
        if token:
            return token, t

    raise TokenException("Content not parsable: '%s'" % (string))


class Stack:

    def __init__(self):
        self.lst = []

    def push(self, value):
        self.lst.append(value)

    def pop(self):
        return self.lst.pop(-1)

    def empty(self):
        return len(self.lst) == 0

    def peek(self):
        return self.lst[-1]


class Package:

    def __init__(self, name, version=None):
        self.name = name
        self.version = version

    def __str__(self):
        if not self.name:
            return ""

        if self.version:
            return "%s(%s)" % (self.name, self.version)
        else:
            return self.name


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("-n", "--name", required=True,
                        help="package name", type=str)
    parser.add_argument("-v", "--version", required=True, help="package "
                        "version", type=str)
    parser.add_argument("-d", "--dependencies", required=True, help="package "
                        "dependencies as comma separated list", type=str,
                        nargs='+')
    parser.add_argument("-m", "--maintainer", help="package maintainer",
                        default="generated by adebi", type=str)
    parser.add_argument("-e", "--email", help="email of package maintainer",
                        default="adebi@adebi.com", type=str)
    parser.add_argument("-s", "--simulate", help="simulate installation only",
                        action='store_true')
    parser.add_argument("-p", "--package-only", help="creates a debian "
                        "package and places it in the current directory",
                        action="store_true")

    args = parser.parse_args()

    gdebi_opts = []
    if args.simulate:
        gdebi_opts = gdebi_opts.append("--apt-line")

    deps_in = " ".join(args.dependencies).strip(" \n\t,")
    packages = []
    stack = Stack()

    for token in tokenize(deps_in):
        if token[1] == PACKAGE:
            if not stack.empty():
                name = stack.pop()
                packages.append(Package(name))
            stack.push(token[0])
        elif token[1] == VERSION:
            if stack.empty():
                raise TokenException("Version without leading package "
                                     "name specified")
            name = stack.pop()
            version = token[0]
            packages.append(Package(name, version))

    dependencies = ", ".join(str(i) for i in packages)
    print dependencies

    tempdir = tempfile.mkdtemp(prefix="adebi")
    current = os.getcwd()
    os.chdir(tempdir)
    filename = "%s.control" % (args.name)
    try:
        with open(filename, 'w') as control_file:
            control_file.write(
                "Package: %s\n"
                "Version: %s\n"
                "Maintainer: %s <%s>\n"
                "Depends: %s\n" % (args.name, args.version, args.maintainer,
                                   args.email, dependencies)
            )

        subprocess.check_call(["/usr/bin/equivs-build", filename])
        if args.package_only is False:
            subprocess.check_call(["/usr/bin/gdebi", "%s_%s_all.deb"
                                   % (args.name, args.version)] + gdebi_opts)
        else:
            deb_files = glob.glob('./*.deb')
            for deb_file in deb_files:
                shutil.move(deb_file, current)
            cleanup(current, tempdir)
            sys.exit(0)

    except Exception as e:
        cleanup(current, tempdir)
        print >> sys.stderr, '[Error] %s' % (e)
        sys.exit(255)

    print "Package '%s' successfully installed." % (args.name)
    print "Run 'apt-get remove %s' to " \
          "remove the package and it's dependencies." % (args.name)
    cleanup(current, tempdir)

if __name__ == '__main__':
    main()
